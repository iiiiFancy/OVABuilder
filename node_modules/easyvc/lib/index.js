'use strict'

/**
 * Easy wrapper for vSphere operations.
 *
 * nanw@vmware.com
 *
 */

const mob = require('./mob')
const SessionManager = require('./session-manager.js')

class EasyVc {

	constructor() {
		Object.defineProperty(this, 'first', { value: o => Array.isArray(o) ? o[0] : o })
		this.host = null
		this._redirectErrorToConsole = false
	}

	async login(host, user, password) {
		this.host = host
		return SessionManager.login(host, user, password).then(() => this)
	}

	async logout() {
		return SessionManager.logout(this.host)
	}

	async _service() {
		return SessionManager.ensureSession(this.host)
	}

	_serviceDirect() {
		return SessionManager.get(this.host).service
	}

	isLoggedIn() {
		return !!SessionManager.get(this.host)
	}

	enableLog() {
		this._redirectErrorToConsole = true
		return this
	}

	log() {
		this._redirectErrorToConsole && console.log.apply(arguments)
	}

	isVCenter() {
		return this._serviceDirect().serviceContent.about.apiType === 'VirtualCenter'	//'HostAgent'
	}

	async _getProp(mor, name) {
		let svc = await this._service()
		let vimPort = svc.vimPort,
			vim = svc.vim,
			propertyCollector = svc.serviceContent.propertyCollector

		let ret = await vimPort.retrievePropertiesEx(propertyCollector, [
			vim.PropertyFilterSpec({
				objectSet: vim.ObjectSpec({
					obj: mor,
					skip: false,
				}),
				propSet: vim.PropertySpec({
					type: mor.type,
					pathSet: [name]
				})
			})
		], vim.RetrieveOptions())

		if (ret.objects[0].propSet[0] === undefined)
			return Promise.resolve()
		return Promise.resolve(ret.objects[0].propSet[0].val)
	}

	///////////////////////////////////////////////////////////////////////////////////////
	async findHostByIp(ip, optionalDatacenter) {
		return this.findByIp(ip, false, optionalDatacenter)
	}

	async findByIp(ip, findVm, optionalDatacenter) {
		findVm = !!findVm
		let svc = await this._service()
		let mor = await svc.vimPort.findByIp(svc.serviceContent.searchIndex, optionalDatacenter, ip, findVm)
		if (!mor)
			return Promise.reject(`findByIp: not found. ip=${ip}, findVM=${findVm}, dc=${optionalDatacenter}`)
		return mob(svc, mor)
	}

	async validateVC(host, user, password) {
		let ME = this
		function verify() {
			return ME.login(host, user, password)
				.catch(err => Promise.reject('Error validating VC login: host=' + host + ', user=' + user + ', err=' + err))
		}

		//due to a vsphere js sdk limitation, duplicated login always fail. Logout first
		if (this.isLoggedIn())
			return this.logout().catch(() => { }).then(verify)
		return verify()
	}


	///////////////////////////////////////////////////////////////////////////////////////
	/**
	 * @param {Array<string>} type	
	 * @param {Array<vsphere.vimService.vim.PropertySpec>} propertySpec
	 * @return {Object[]} Promise<Array>
	 */
	async retrieveProperties(type, propertySpec) {
		let svc = await this._service()
		let propertyCollector = svc.serviceContent.propertyCollector,
			rootFolder = svc.serviceContent.rootFolder,
			viewManager = svc.serviceContent.viewManager,
			vim = svc.vim,
			vimPort = svc.vimPort

		let containerView = await vimPort.createContainerView(viewManager, rootFolder, type, true)
		let specs = [
			vim.PropertyFilterSpec({
				objectSet: vim.ObjectSpec({
					obj: containerView,
					skip: true,
					selectSet: vim.TraversalSpec({
						path: 'view',
						type: 'ContainerView'
					})
				}),
				propSet: propertySpec
			})
		]

		return vimPort.retrieveProperties(propertyCollector, specs)
	}

	async getDatastores() {
		let svc = await this._service()
		let propertySpec = svc.vim.PropertySpec({
			type: 'Datastore',
			pathSet: ['name']
		})
		return this.retrieveProperties(['Datastore'], propertySpec)
	}

	async getDatacenter(esxiIp) {
		let esxiHost = await this.findHostByIp(esxiIp)
		return esxiHost.getDatacenter()
	}

	async getEsxiDatacenterName(esxiIp) {
		let esxiHost = await this.findHostByIp(esxiIp)
		let datacenter = await esxiHost.getDatacenter()
		return datacenter.get('name')
	}

	/**
	 * @param {object} mob
	 * @param {string} name
	 * @return {Object} Promise<string> valid VM name
	 */
	async avoidSameName(mob, name) {
		let calcUniqueName = async (vms, name, index) => {
			let testName = index ? (name + ' (' + index + ')') : name			
			for (let i=0; i<vms.length; ++i) {
				let vm = vms[i]

				let vmName = await vm.get('name')
				if (vmName === testName)
					return await calcUniqueName(vms, name, index + 1)
			}
				
			return testName
		}
		
		let vms = await mob.get('vm')

		return await calcUniqueName(vms, name, 0)
	}

	async findObjByName(propertyType, name) {
		let svc = await this._service()

		let vim = svc.vim
		let propSet = []
		if (Array.isArray(propertyType)) {
			propertyType.forEach((type) => {
				let propertySpec = vim.PropertySpec({
					type: type,
					pathSet: ['name']
				})
	
				propSet.push(propertySpec)	
			})
		}
		else {		
			let propertySpec = vim.PropertySpec({
				type: propertyType,
				pathSet: ['name']
			})

			propSet.push(propertySpec)
		}		
		
		let dataArray = await this.retrieveProperties(propertyType, propSet)
		for (let i = 0; i < dataArray.length; i++) {
			let dt = dataArray[i]
			if (dt.propSet[0].val === name)
				return dt.obj
		}
		return Promise.reject(`findObjByName: not found. type=${propertyType}, name=${name}`)
	}

	async createVM(vmName, isoPath, autounattendIsoPath, resourceLocation) {

		let isEsxi = this._serviceDirect().serviceContent.about.apiType === 'HostAgent'
		
		let datastoreName = resourceLocation.datastore
		let networkName = resourceLocation.network
		let networkMor = await this.findObjByName('Network', networkName)
		let networkType = networkMor.type

		let ME = this
		let svc = await this._service()
		let vim = svc.vim
		let vimPort = svc.vimPort
		

		async function initNetwork() {
			let virtualE1000 = {
				deviceInfo: vim.Description({
					label: 'New Network',
					summary: 'New Network'
				}),

				addressType: isEsxi ? 'generated' : 'assigned', //'assigned' just only support create vm at vcenter, not support create vm at esxi				
				connectable: vim.VirtualDeviceConnectInfo({
					allowGuestControl: true,
					connected: true,
					startConnected: true
				}),
				controllerKey: 100,
				key: -109,
				wakeOnLanEnabled: true,
				unitNumber: 7,
				/*slotInfo: vim.VirtualDeviceBusSlotInfo({
					pciSlotNumber: 192
				})*/
			}

			if (networkType === 'DistributedVirtualPortgroup') {
				async function genVirtualPortBackingInfo(networkName) {
					ME.network = await ME.findObjByName('Network', networkName)
					let virtualSwitch = await ME._getProp(ME.network, 'config.distributedVirtualSwitch')
					ME.uuid = await ME._getProp(virtualSwitch, 'uuid')
					let key = await ME._getProp(ME.network, 'key')
					return vim.VirtualEthernetCardDistributedVirtualPortBackingInfo({
						port: vim.DistributedVirtualSwitchPortConnection({
							portgroupKey: key,
							switchUuid: ME.uuid
						})
					})
				}

				virtualE1000.backing = await genVirtualPortBackingInfo(networkName)
				return virtualE1000
			} else {
				virtualE1000.backing = vim.VirtualEthernetCardNetworkBackingInfo({
					deviceName: networkName || 'VM Network',
					//useAutoDetect: false,
					network: networkMor
				})
				return virtualE1000
			}
		}

		async function createVmConfigSpec(name, datastoreMor) {
			let networkConfig = await initNetwork()
			// VMFI
			let vmfi = vim.VirtualMachineFileInfo({
				vmPathName: '[' + datastoreName + ']'
			})

			let virtualSCSI = vim.VirtualLsiLogicSASController({
				key: 1000,
				busNumber: 0,
				sharedBus: vim.VirtualSCSISharing.noSharing
			})

			let SCSISpec = vim.VirtualDeviceConfigSpec({
				device: virtualSCSI,
				operation: vim.VirtualDeviceConfigSpecOperation.add
			})

			let virtualDisk = vim.VirtualDisk({
				capacityInKB: 40000000,
				key: 2000,
				unitNumber: 0,
				controllerKey: 1000,
				backing: vim.VirtualDiskFlatVer2BackingInfo({
					fileName: '[' + datastoreName + ']',// + vmName + '/' + vmName + '.vmdk',
					diskMode: 'persistent',
					thinProvisioned: true,
					datastore: datastoreMor
				})
			})

			let DiskSpec = vim.VirtualDeviceConfigSpec({
				device: virtualDisk,
				operation: vim.VirtualDeviceConfigSpecOperation.add,
				fileOperation: vim.VirtualDeviceConfigSpecFileOperation.create
			})

			let virtualNic = vim.VirtualVmxnet3(networkConfig)

			let NicSpec = vim.VirtualDeviceConfigSpec({
				device: virtualNic,
				operation: vim.VirtualDeviceConfigSpecOperation.add
			})

			let virtualIsoCdrom = vim.VirtualCdrom({
				backing: vim.VirtualCdromIsoBackingInfo({
					datastore: datastoreMor,
					fileName: isoPath
				}),
				connectable: vim.VirtualDeviceConnectInfo({
					allowGuestControl: true,
					connected: true,
					startConnected: true
				}),
				controllerKey: 200,
				key: 3000,
				unitNumber: 0
			})
			let IsoCdromSpec = vim.VirtualDeviceConfigSpec({
				device: virtualIsoCdrom,
				operation: vim.VirtualDeviceConfigSpecOperation.add
			})

			let virtualIsoCdrom2 = vim.VirtualCdrom({
				backing: vim.VirtualCdromIsoBackingInfo({
					datastore: datastoreMor,
					fileName: autounattendIsoPath
				}),
				connectable: vim.VirtualDeviceConnectInfo({
					allowGuestControl: true,
					connected: true,
					startConnected: true
				}),
				controllerKey: 200,
				key: 3001,
				unitNumber: 1
			})
			let IsoCdromSpec2 = vim.VirtualDeviceConfigSpec({
				device: virtualIsoCdrom2,
				operation: vim.VirtualDeviceConfigSpecOperation.add
			})

			let virtualAtapiCdrom = vim.VirtualCdrom({
				backing: vim.VirtualCdromRemoteAtapiBackingInfo({
					deviceName: '',
					useAutoDetect: false
				}),
				connectable: vim.VirtualDeviceConnectInfo({
					allowGuestControl: true,
					connected: false,
					startConnected: false
				}),
				controllerKey: 201,
				key: 3002,
				unitNumber: 0
			})

			let AtapiCdromSpec = vim.VirtualDeviceConfigSpec({
				device: virtualAtapiCdrom,
				operation: vim.VirtualDeviceConfigSpecOperation.add
			})

			let memoryMB = 4096
			let cpuNum = 2
			// key point: specify VM config
			let vmConfigSpec = vim.VirtualMachineConfigSpec({
				name: name,
				annotation: 'VM Annotation',
				memoryMB: memoryMB,
				numCPUs: cpuNum,
				guestId: 'windows8Server64Guest',	//windows8Server64Guest  (2012)
				deviceChange: [						// specify devices
					SCSISpec,
					DiskSpec,
					NicSpec,
					IsoCdromSpec,
					IsoCdromSpec2,
					AtapiCdromSpec
				],
				files: vmfi
			})

			return vmConfigSpec
		} 

		async function createVM(vmFolder, vmConfigSpec, pool) {
	
			ME.log('start creating VM')
			// start create VM task
			let task = await vimPort.createVMTask(vmFolder.mor, vmConfigSpec, pool.mor)
			let vmTask = mob(svc, task)
			// wait for task success																				
			await vmTask.waitState('info.state', vim.TaskInfoState.success.toString(), 4 * 60 * 1000) // extend timeout to avoid failed when ehostunreach

			// create VM success								
			// check VM MOR
			let result = await vmTask.get('info')

			let vmMor = result.result
			ME.log('create VM complete')
			return mob(svc, vmMor)
		}

		try {			
			// Datacenter
			let datacenter
			let datacenterName = resourceLocation.datacenter
			if (datacenterName && datacenterName !== '') {
				let dcMor = await this.findObjByName('Datacenter', datacenterName)
				datacenter = this.Mob(dcMor)
			}
			else {
				let hostIp = resourceLocation.esxi
				let hostSystem = await this.findHostByIp(hostIp)
				let cluster = await hostSystem.get('parent')
				let hostFolder = await cluster.get('parent')
				datacenter = await hostFolder.get('parent')  
			}
			
			// Folder
			let vmFolder
			let folderName = resourceLocation.folder
			if (folderName && folderName !== '' && folderName !== datacenterName) {
				let vmFolderMor = await this.findObjByName('Folder', folderName)
				vmFolder = this.Mob(vmFolderMor)
			}
			else {
				vmFolder = await datacenter.get('vmFolder')
			}
			
			// Cluster
			let cluster
			let clusterName = resourceLocation.cluster
			if (clusterName && clusterName !== '') {
				let clusterMor = await this.findObjByName(['ComputeResource', 'ClusterComputeResource'], clusterName)
				cluster = this.Mob(clusterMor)
			}
			else {
				let hostIp = resourceLocation.esxi
				let hostSystem = await this.findHostByIp(hostIp)
				cluster = await hostSystem.get('parent')
			}

			// ResourcePool
			let resourcePool
			let resourcePoolName = resourceLocation.resourcePool
			if (resourcePoolName && resourcePoolName !== '' && resourcePoolName !== clusterName) {
				let resourcePoolMor = await this.findObjByName('ResourcePool', resourcePoolName)
				resourcePool = this.Mob(resourcePoolMor)
			}
			else {
				resourcePool = await cluster.get('resourcePool')
			}

			// Datastore
			let datastoreMor = await this.findObjByName('Datastore', datastoreName)
						
			let name = await this.avoidSameName(resourcePool, vmName)			
			let vmConfigSpec = await createVmConfigSpec(name, datastoreMor)			
			return createVM(vmFolder, vmConfigSpec, resourcePool)

		} catch (e) {
			let msg = 'Error creating VM, err=' + e
			this.log(msg)
			return Promise.reject(e)
		}
	}

	/**	 
	 * @param {string} vmNameOrRegExp
	 * @return {Object} Promise<[VirtualMachine, ...]>
	 */
	async findVMsByName(vmNameOrRegExp) {
		let svc = await this._service()
		let rootFolder = svc.serviceContent.rootFolder
		let viewManager = svc.serviceContent.viewManager
		let propertyCollector = svc.serviceContent.propertyCollector
		let vimPort = svc.vimPort
		let vim = svc.vim

		function retrieveProperty(containerView) {
			let specSet = [
				vim.PropertyFilterSpec({
					objectSet: [
						vim.ObjectSpec({
							obj: containerView,
							skip: true,//false,
							selectSet: [
								vim.TraversalSpec({
									name: 'traverseEntities',
									path: 'view',
									skip: false,
									type: 'ContainerView'
								})
							]
						})
					],
					propSet: [
						vim.PropertySpec({
							type: 'VirtualMachine',
							pathSet: ['name']
						})
					]
				})
			]
			let retrieveOptions = vim.RetrieveOptions()
			return vimPort.retrievePropertiesEx(propertyCollector, specSet, retrieveOptions)
		}

		let finalResults = []
		function processResults(results) {
			let properties = results.objects.map(function (result) {
				if (!result.propSet || !result.propSet[0]) {
					console.error('invalid propSet: ' + JSON.stringify(results) + ' at findVMsByName')
					return
				}

				let mor = result.obj
				let name = result.propSet[0].val
				let vm = mob(svc, mor)
				vm.name = name
				return vm
			})

			const filterByName = p => p.name === vmNameOrRegExp
			const filterByRegExp = p => p.name.match(vmNameOrRegExp)
			let filterFunc = vmNameOrRegExp instanceof RegExp ? filterByRegExp : filterByName
			let tmp = properties.filter(filterFunc)
			finalResults = finalResults.concat(tmp)
		}

		function processAndContinue(results) {
			if (!results || !results.objects)
				return Promise.resolve(finalResults)

			processResults(results)

			if (!results.token)
				return Promise.resolve(finalResults)

			return vimPort.continueRetrievePropertiesEx(propertyCollector, results.token)
				.then(processAndContinue)
		}

		let recursive = true
		return vimPort.createContainerView(viewManager, rootFolder, ['VirtualMachine'], recursive)
			.then(retrieveProperty)
			.then(processAndContinue)
	}


	async createDatacenter(name) {
		let svc = await this._service()
		let mor = await svc.vimPort.createDatacenter(svc.serviceContent.rootFolder, name)
		return mob(svc, mor)
	}

	async addStandaloneHost(esxiHost, esxiUser, esxiPassword, esxiLicense, esxiSSLThumbprint, datacenterMor) {
		let svc = await this._service()

		let hostFolderMor = await this._getProp(datacenterMor, 'hostFolder')
		let vmFolderMor = await this._getProp(datacenterMor, 'vmFolder')
		let vim = svc.vim
		let vimPort = svc.vimPort
		let hostConnectSpec = vim.HostConnectSpec({
			force: false,
			hostName: esxiHost,
			lockdownMode: vim.HostLockdownMode.lockdownDisabled,
			userName: esxiUser,
			password: esxiPassword,
			port: 443,
			vmFolder: vmFolderMor,
			sslThumbprint: esxiSSLThumbprint || ''
		})

		let computeResourceSpec = vim.ComputeResourceConfigSpec({
			vmSwapPlacement: vim.VirtualMachineConfigInfoSwapPlacementType.vmDirectory
		})

		let taskMor = await vimPort.addStandaloneHostTask(hostFolderMor, hostConnectSpec, computeResourceSpec, true, esxiLicense)

		let task = mob(svc, taskMor)
		return task.waitState('info.state', 'success')
	}

	async removeStandaloneHost(esxiHost) {
		let svc = await this._service()
		let vim = svc.vim
		let vimPort = svc.vimPort
		let hostSystem = await this.findHostByIp(esxiHost)
		let computeResource = await hostSystem.get('parent')
		let taskMor = await vimPort.destroyTask(computeResource.mor)
		let destroyTask = mob(svc, taskMor)

		return destroyTask.waitState('info.state', vim.TaskInfoState.success.toString())
	}

	async licenseManager() {
		let svc = await this._service()
		return mob(svc, svc.serviceContent.licenseManager)
	}

	async createVsanDirectory(datastoreName, dirName) {
		let datastoreMor = await this.findObjByName('Datastore', datastoreName)
		let datastore = this.Mob(datastoreMor)
		return datastore.createDirectory(dirName)
			.catch(() => Promise.resolve())
	}

	async makeDirectory(datacenterMor, datastoreName, dirName) {
		let svc = await this._service()
		let vimPort = svc.vimPort
		let fileManager = svc.serviceContent.fileManager
		let path = `[${datastoreName}] ${dirName}`
		let createParentDirectories = true
		return vimPort.makeDirectory(fileManager, path, datacenterMor, createParentDirectories)
			.catch(() => Promise.resolve())
	}

	async createImportSpecParams(vmName, networkMor, propertyMapping) {
		let svc = await this._service()
		let vim = svc.vim

		let cisp = new vim.OvfCreateImportSpecParams()
		cisp.deploymentOption = ''
		cisp.diskProvisioning = 'thin'
		cisp.entityName = vmName

		let instantiationOst = new vim.OvfConsumerOstNode()
		instantiationOst.id = ''
		instantiationOst.type = vim.OvfConsumerOstNodeType.envelope
		cisp.instantiationOst = instantiationOst

		cisp.ipAllocationPolicy = vim.VAppIPAssignmentInfoIpAllocationPolicy.fixedPolicy
		cisp.ipProtocol = 'IPv4'
		cisp.locale = 'US'
		
		let networkMapping = new vim.OvfNetworkMapping()
		networkMapping.name = 'Network 1'
		networkMapping.network = networkMor

		cisp.networkMapping = [networkMapping]
		let properties = []
		propertyMapping.forEach((value, key) => {
			properties.push(vim.KeyValue({
				key: key,
				value: value
			}))
		})
		cisp.propertyMapping = properties

		return cisp
	}

	async createImportSpec(ovfContent, datastoreMor, resourePoolMor, cisp) {
		let svc = await this._service()
		let vimPort = svc.vimPort
		let ovfManager = svc.serviceContent.ovfManager
		return vimPort.createImportSpec(ovfManager, ovfContent, resourePoolMor, datastoreMor, cisp)
	}

	async importVApp(resourcePoolMor, importSpec, vmFolderMor, hostSystemMor) {
		let svc = await this._service()
		let httpNfcLeaseMor = await svc.vimPort.importVApp(resourcePoolMor, importSpec, vmFolderMor, hostSystemMor)
		return mob(svc, httpNfcLeaseMor)
	}

	Mob(mor) {
		return mob(this._serviceDirect(), mor)
	}

	/**
	 * clone vm through template
	 *
	 * @param {string} templateName
	 * @param {string} cloneVmName
	 * @param {boolean} powerOn
	 * @param {ManagedObjectReference} folderMor
	 * @param {ManagedObjectReference} resPoolMor
	 * @param {ManagedObjectReference (Optional)} dataStoreMor
	 * @returns {Promise<*>}
	 */
	async cloneVMByTemplate(templateName, cloneVmName, powerOn, folderMor, resPoolMor, dataStoreMor, customizationSpec) {
	
		let vms = await this.findVMsByName(templateName)
		if (vms.length == 0)
			return Promise.reject(`${templateName} does not exist`)
		let vm = vms[0]

		let diskKeys = await vm.getIndependenetVirtualDiskKeys()
		if (diskKeys.length > 0)
			return Promise.reject('Clone not support for vm contains independent disk')


		let svc = await this._service()
		let vim = svc.vim
		let vimPort = svc.vimPort

		let rSpec = new vim.VirtualMachineRelocateSpec()
		rSpec.pool = resPoolMor		
		rSpec.datastore = dataStoreMor

		let cloneSpec = new vim.VirtualMachineCloneSpec()
		cloneSpec.powerOn = powerOn
		cloneSpec.template = false
		cloneSpec.location = rSpec
		cloneSpec.config = new vim.VirtualMachineConfigSpec()
		if (customizationSpec)
			cloneSpec.customization = customizationSpec
	
		let cloneTaskMor = await vimPort.cloneVMTask(vm.mor, folderMor, cloneVmName, cloneSpec)
		let cloneTask = mob(svc, cloneTaskMor)

		await cloneTask.waitState('info.state', vim.TaskInfoState.success.toString(), 60 * 60 * 1000)
	}

	async listDatacenters() {
		let svc = await this._service()		
		let rootFolder = svc.serviceContent.rootFolder
		
		return this._getProp(rootFolder, 'childEntity')
	}

	async createCustomizationSpec4Win(customizationSpecItem) {
		let svc = await this._service()
		let vim = svc.vim
		let vimPort = svc.vimPort
		let customizationSpecManager = svc.serviceContent.customizationSpecManager
		
		let spec = customizationSpecItem.spec

		let computerName = spec.identity.userData.computerName
		let item = vim.CustomizationSpecItem({
			info: vim.CustomizationSpecInfo(customizationSpecItem.info),
			spec: vim.CustomizationSpec({
				globalIPSettings: vim.CustomizationGlobalIPSettings(spec.globalIPSettings),
				identity: vim.CustomizationSysprep({
					guiUnattended: vim.CustomizationGuiUnattended({
						autoLogon: spec.identity.guiUnattended.autoLogon,
						autoLogonCount: spec.identity.guiUnattended.autoLogonCount, 	
						password: vim.CustomizationPassword({
							plainText: spec.identity.guiUnattended.password.plainText,
							value: spec.identity.guiUnattended.password.value
						}),
						timeZone: spec.identity.guiUnattended.timeZone
					}),
					licenseFilePrintData: vim.CustomizationLicenseFilePrintData({
						autoMode: spec.identity.licenseFilePrintData.autoMode,
						autoUsers: spec.identity.licenseFilePrintData.autoUsers
					}),
					userData: vim.CustomizationUserData({
						computerName: (computerName && computerName !== '') ? vim.CustomizationFixedName({name: computerName}) : vim.CustomizationVirtualMachineName(),
						fullName: spec.identity.userData.fullName,	
						orgName: spec.identity.userData.orgName,
						productId: spec.identity.userData.productId
					})
				}),
				options: vim.CustomizationWinOptions({
					changeSID: spec.options.changeSID || true,
					deleteAccounts: spec.options.deleteAccounts || false
				})
			})
		})

		let joinWorkgroup = spec.identity.identification.joinWorkgroup
		if (joinWorkgroup && joinWorkgroup !== '') {
			Object.assign(item.spec.identity, {identification: vim.CustomizationIdentification({
				joinWorkgroup: joinWorkgroup
			})})
		} else {
			Object.assign(item.spec.identity, {identification: vim.CustomizationIdentification({
				domainAdmin: spec.identity.identification.domainAdmin,
				domainAdminPassword: vim.CustomizationPassword({
					plainText: spec.identity.identification.domainAdminPassword.plainText,
					value: spec.identity.identification.domainAdminPassword.value
				}),	
				joinDomain: spec.identity.identification.joinDomain
			})})
		}
			

		if (spec.identity.guiRunOnce)
			Object.assign(item.spec.identity, {guiRunOnce: vim.CustomizationGuiRunOnce(spec.identity.guiRunOnce)})
		
		if (spec.nicSettingMap) {
			let nicSettingMap = []
			spec.nicSettingMap.forEach((nic) => {
				let ipAddress = nic.adapter.ip.ipAddress
				let nicSetting = vim.CustomizationAdapterMapping({
					macAddress: nic.macAddress || null,
					adapter: vim.CustomizationIPSettings({
						dnsDomain: nic.adapter.dnsDomain || null,
						dnsServerList: nic.adapter.dnsServerList,
						gateway: nic.adapter.gateway,
						ip: (ipAddress && ipAddress !== '') ? vim.CustomizationFixedIp({ipAddress: ipAddress}) : vim.CustomizationDhcpIpGenerator(),
						netBIOS: nic.adapter.netBIOS || 'disableNetBIOS',
						primaryWINS: nic.adapter.primaryWINS || '',
						secondaryWINS: nic.adapter.secondaryWINS || '',
						subnetMask: nic.adapter.subnetMask
					})
				})

				nicSettingMap.push(nicSetting)
			})

			item.spec.nicSettingMap = nicSettingMap
		}

		return vimPort.createCustomizationSpec(customizationSpecManager, item)
	}
}

module.exports = () => new EasyVc
