'use strict'

const BaseMob = require('../BaseMob.js')
const mob = require('../mob.js')

class HostSystem extends BaseMob {
	async findNetworkByName(name) {
		let networks = await this.get('network')
		let network
		for (let i=0; i<networks.length; i++) {
			let curNetwork = networks[i]
			let curName = await curNetwork.get('name')
			if (curName === name) {
				network = curNetwork
				break
			}
		}

		return network
	}
    
	async recommendDatastore(freeSpaceFirst) {
		let datastores = await this.get('datastore')
		let config = await this.get('config')

		function isDatastoreReadonly(name) {
			if (!(config && config.fileSystemVolume && config.fileSystemVolume.mountInfo))
				return

			var mountInfo = config.fileSystemVolume.mountInfo
			//for (m of mountInfo) {
			for (var i = 0; i < mountInfo.length; i++) {
				var m = mountInfo[i]
				if (m.volume.name === name) {
					return m.mountInfo.accessMode === 'readOnly'
				}
			}
		}

		var best
		var bestSSD
		var processed = 0

		for (var i = 0; i < datastores.length; i++) {

			var ds = datastores[i]
			let props = await ds.get(['summary', 'info'])

			//TODO------
			//check mount info to get readonly state, from host: 
			//  config  HostConfigInfo
			//      fileSystemVolume (HostFileSystemVolumeInfo)
			//          mountInfo   (HostFileSystemMountInfo[])
			//config.fileSystemVolume.mountInfo

			//console.log(props);
			var isReadonly = isDatastoreReadonly(props.summary.name)
			if (isReadonly)
				console.log('READONLY: ' + props.summary.name)

			if (props.summary.accessible && !isReadonly) {
				if (!best || props.summary.freeSpace > best.summary.freeSpace)
					best = props
				if (!freeSpaceFirst && props.info.vmfs && props.info.vmfs.ssd && props.summary.freeSpace > 1024 * 1024 * 1024 * 100 && (!bestSSD || props.summary.freeSpace > bestSSD.summary.freeSpace))
					bestSSD = props
			}

			if (++processed == datastores.length) {
				best = bestSSD ? bestSSD : best
				var ret = mob(this._serviceDirect(), best.summary.datastore)
				ret.summary = best.summary
				ret.info = best.info
				return ret
			}
		}      
	}


	// appended by huang.
	async selectedDatastoreByName(datastoreName) {
		console.log('datastoreName in selectedDatastoreByName(): ', datastoreName)
		let datastores = await this.get('datastore')
		for (let i = 0; i < datastores.length; i++) {
			let ds = datastores[i]
			let props = await ds.get(['summary', 'info'])
			if (props.summary.name == datastoreName) {
				console.log('datastore props.summary.name: ', props.summary.name, '; datastoreName: ', datastoreName)
				let ret = mob(this._serviceDirect(), props.summary.datastore)
				ret.summary = props.summary
				ret.info = props.info
				return ret
			}
		}

		return null
	
	}

	// to list all the datastore.
	async listAllDatastoresName() {

		let datastores = await this.get('datastore')
		let config = await this.get('config')
		function isDatastoreReadonly(name) {
			if (!(config && config.fileSystemVolume && config.fileSystemVolume.mountInfo))
				return

			let mountInfo = config.fileSystemVolume.mountInfo
			for (let i = 0; i < mountInfo.length; i++) {
				let m = mountInfo[i]
				if (m.volume.name === name)
					return m.mountInfo.accessMode === 'readOnly'
			}
		}

		let datastoresNameList = []
		for (let i = 0; i < datastores.length; i++) {
			let datastoreInfo = await datastores[i].get(['summary', 'info'])
			let isReadonly = isDatastoreReadonly(datastoreInfo.summary.name)
			if (isReadonly)
				console.log('DATASTORE READONLY: ' + datastoreInfo.summary.name)
			else
				datastoresNameList.push(datastoreInfo.summary.name)
		}

		return datastoresNameList

	}

	async isNetworkDownLink(network) {
		
		let name = await network.get('name')
		let configInfo = await network.get('config')
		if ((configInfo != null) && configInfo['uplink'])
			return {'uplink': true, 'name' : name}
		else
			return {'uplink' : false, 'name' : name}
	
	}

	async listAllNetworks() {

		let networks = await this.get('network')
		let networkDownlink = []
		for (let i = 0; i < networks.length; i++) {
			let res =  await this.isNetworkDownLink(networks[i])
			if (res && (!res.uplink))
				networkDownlink.push(res.name)
		}

		return networkDownlink
	}

	getDatacenter() {
		return this.parent('Datacenter')
	}

	async getDatacenterVmFolder() {

		let datacenter = await this.getDatacenter()
		let vmFolder = await datacenter.get('vmFolder')

		return vmFolder
	}

	async getResourcePool() {

		let resource = await this.parent('ClusterComputeResource')
		if (resource === undefined)
			resource = await this.parent('ComputeResource')

		let pool = await resource.get('resourcePool')

		return pool
	}

	async createNasDatastore(name, remoteHost, remotePath) {
		let svc = await this._service()

		let storage = svc.vim.HostNasVolumeSpec({
			accessMode: 'readOnly', // 'readWrite'
			localPath: name,
			remoteHost: remoteHost,
			remotePath: remotePath
		})

		let dssystem = await this.get('configManager.datastoreSystem')
		let datastore = await svc.vimPort.createNasDatastore(dssystem.mor, storage)

		return datastore

	}
}


module.exports = HostSystem
